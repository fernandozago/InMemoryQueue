@page "/queues"
@inject HttpClient Http

<PageTitle>InMemory Queues</PageTitle>

<table class="table">
    <thead>
        <tr>
            <th scope="col" class="table-light text-center" colspan="3">Overview</th>
            <th scope="col" colspan="1" class="table-info text-center">Messages</th>
            <th scope="col" colspan="5" class="table-success  text-center">Message rates</th>
        </tr>
        <tr>
            <th scope="col" class="table-light">Name</th>
            <th scope="col" class="table-light text-center">Consumers</th>
            <th scope="col" class="table-light text-center">State</th>
            <th scope="col" class="table-info text-center">Ready</th>
            <th scope="col" class="table-success text-right">Incoming</th>
            <th scope="col" class="table-success text-right">Deliver / Redeliver</th>
            <th scope="col" class="table-success text-right">Ack</th>
            <th scope="col" class="table-success text-right">Nack</th>
            <th scope="col" class="table-success text-right">Avg. Consume</th>
        </tr>
    </thead>
    <tbody>
        @foreach (var queue in _activeQueues ?? Array.Empty<Queue>())
        {
            <tr>
                <td><NavLink class="nav-link" href="@($"dashboard/{queue.Name}")">@queue.Name</NavLink></td>
                <td class="text-center">@queue.ConsumersCount.ToString("N0")</td>
                <td class="text-center">@GetState(queue)</td>
                <td class="text-center">@queue.QueueCount.ToString("N0")</td>
                <td class="text-right">@queue.Counters.PubPerSecond.ToString("N0")</td>
                <td class="text-right">@((queue.Counters.DeliverPerSecond + queue.Counters.RedeliverPerSecond).ToString("N0"))</td>
                <td class="text-right">@queue.Counters.AckPerSecond.ToString("N0")</td>
                <td class="text-right">@queue.Counters.NackPerSecond.ToString("N0")</td>
                <td class="text-right">@queue.Counters.AvgAckTimeMilliseconds.ToString("N5") ms</td>
            </tr>
        }
    </tbody>
    <tbody>
    </tbody>
</table>
@code {
    private Queue[]? _activeQueues = null;
    private CancellationTokenSource? _cts;
    private Task? _backgroundTask;

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            _cts = new CancellationTokenSource();
            _backgroundTask = Task.Run(async () =>
            {
                while (!_cts.IsCancellationRequested)
                {
                    await GetActiveQueuesAsync();
                    StateHasChanged();
                    await Task.Delay(1000);
                }
            });
        }
        base.OnAfterRender(firstRender);
    }

    private string GetState(Queue queue)
    {
        if (queue.Counters.PubPerSecond == 0 
            && queue.Counters.NackPerSecond == 0
            && queue.Counters.AckPerSecond == 0
            && queue.Counters.DeliverPerSecond == 0
            && queue.Counters.RedeliverPerSecond == 0)
        {
            return "Idle";
        }
        else
        {
            return "Processing";
        }
    }

    private async Task GetActiveQueuesAsync()
    {
        _activeQueues = null;
        try
        {
            _activeQueues = (await Http.GetFromJsonAsync<Queue[]?>("InMemoryQueue/GetActiveQueues"))?.OrderBy(x => x.Name).ToArray();
        }
        catch
        {
            //
        }
    }
}
